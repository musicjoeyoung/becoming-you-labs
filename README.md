# Kanban Task Management System

## Setup Instructions
1. **Prerequisites**
    - Node.js (v18 or higher)
    - npm, yarn, bun, etc.

2. **Installation Steps**
    - Clone the repository
      ```bash
      git clone https://github.com/musicjoeyoung/becoming-you-labs
      cd kanban-task-management
      ```
    - Install dependencies
      ```bash
      npm install
      ```

3. **Running the App**
    - Start the development server
      ```bash
      npm run dev
      ```
    - Open your browser and go to `http://localhost:3000`

4. **Building for Production**
    - Create a production build
      ```bash
      npm run build
      ```
    - Serve the built application
      ```bash
      npm run preview
      ```

## Architecture Overview
This is a Next.js App Router project using the `app/` directory. Pages like the board (`app/page.tsx`), backlog (`app/backlog/page.tsx`), and task detail (`app/task/[id]/page.tsx`) map directly to routes. State lives locally in components via React hooks (no global store) because the scope is small and the data model (tasks) is simple. Tasks are read/written through a tiny storage helper that wraps `localStorage` with an in‑memory fallback so it won’t explode during SSR. Components are split by responsibility: columns render filtered subsets, the card shows a snapshot, the modal handles create/edit, and filters just push updated criteria upward.

Data flow is straight top → down: parent loads all tasks, derives filtered lists, passes them into presentational components, and updates the master list when something changes (drag/drop, edit, new). No server API layer yet—pure client persistence.

## Key Decisions & Tradeoffs
* Local state over Redux/Zustand: faster to ship; global store would be overkill here.
* `localStorage` instead of a backend: keeps the demo self‑contained. Tradeoff: no multi-user sync or persistence across browsers.
* Custom inline SVG icons: icons were generated by AI. 
* Simple theme/styles. I wanted the functionality to be the priority.
* No server components for core views: everything needs hooks (filters, modal state), so staying client-first avoided complexity.
* Minimal TypeScript surface: just enough types (`Task`, `TaskStatus`, `TaskFilters`) to catch mistakes.

## Accessibility & Performance Notes
What’s in place:
* Semantic-ish structure: buttons are real `<button>` elements, form inputs are labeled.
* Modal backdrop clickable and has `role="dialog"` + `aria-modal`.
* Color contrasts mostly rely on Tailwind defaults which are decent.
* Lightweight: no icon packs or state libraries; mostly just React + Tailwind.

Could be better:
* Trap focus inside the modal and return focus to the trigger afterward.
* Add keyboard shortcuts (Esc to close already works via button, but could wire actual key listener).
* Announce status changes to screen readers (ARIA live region).
* Extract repeated inline SVGs into small components for reuse.

## Testing Approach
Kept it mostly manual for now: click through create/edit/delete, drag between columns, apply filters, refresh to confirm persistence. I added some very basic tests for components. (I'm keeping Tailwind v4 but in order to test I have to downgrade to Tailwind v3.)

## Time Spent
Roughly 4 hours total (slightly over 4 hours): setup, planning, components, filtering, modal flow, polish, README/notes.

## If I Had More Time...
* Add due dates + simple reminders.
* Improve style & theme.
* Add sorting controls to the board columns (not just backlog).
* Convert repeated SVGs into a tiny icon system.
* Add more signifcant tests.
* Accessibility polish: focus trap, ARIA labels for icons, announce changes.
* Dark mode toggle.